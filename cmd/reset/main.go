package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/token"
	"os"
	"path/filepath"
	"strings"

	"golang.org/x/tools/go/packages"
)

type StructInfo struct {
	PkgName string
	Dir     string
	Name    string
	Fields  []*ast.Field
	Pkg     *packages.Package
}

func main() {
	cfg := &packages.Config{
		Mode: packages.NeedName | packages.NeedSyntax | packages.NeedFiles,
		Dir:  ".",
		Env:  os.Environ(),
	}

	pkgs, err := packages.Load(cfg, "./...")
	if err != nil {
		fmt.Println("packages.Load:", err)
		return
	}

	found := map[string][]StructInfo{}

	for _, pkg := range pkgs {
		dir := packageDir(pkg)
		if dir == "" {
			continue
		}

		for _, file := range pkg.Syntax {
			for _, decl := range file.Decls {
				gen, ok := decl.(*ast.GenDecl)
				if !ok || gen.Tok != token.TYPE {
					continue
				}
				for _, spec := range gen.Specs {
					ts, ok := spec.(*ast.TypeSpec)
					if !ok {
						continue
					}
					st, ok := ts.Type.(*ast.StructType)
					if !ok {
						continue
					}

					if hasResetComment(gen.Doc) || hasResetComment(ts.Doc) {
						info := StructInfo{
							PkgName: pkg.Name,
							Dir:     dir,
							Name:    ts.Name.Name,
							Fields:  st.Fields.List,
							Pkg:     pkg,
						}
						found[dir] = append(found[dir], info)
					}
				}
			}
		}
	}

	for dir, structs := range found {
		if len(structs) == 0 {
			continue
		}
		sortStructsByName(structs)

		out := bytes.Buffer{}
		out.WriteString("// Code generated by cmd/reset\n")
		out.WriteString("package " + structs[0].PkgName + "\n\n")

		for _, st := range structs {
			out.WriteString(generateResetMethod(st))
			out.WriteString("\n")
		}

		filename := filepath.Join(dir, "reset.gen.go")
		err := os.WriteFile(filename, out.Bytes(), 0644)
		if err != nil {
			fmt.Println("write error:", err)
		} else {
			fmt.Println("generated:", filename)
		}
	}
}

func packageDir(pkg *packages.Package) string {
	if len(pkg.GoFiles) > 0 {
		return filepath.Dir(pkg.GoFiles[0])
	}
	return ""
}

func hasResetComment(cg *ast.CommentGroup) bool {
	if cg == nil {
		return false
	}
	for _, c := range cg.List {
		if strings.Contains(c.Text, "generate:reset") {
			return true
		}
	}
	return false
}

func sortStructsByName(list []StructInfo) {
	for i := 0; i < len(list)-1; i++ {
		for j := i + 1; j < len(list); j++ {
			if list[j].Name < list[i].Name {
				list[i], list[j] = list[j], list[i]
			}
		}
	}
}

func generateResetMethod(st StructInfo) string {
	r := receiverVar(st.Name, st.Pkg)
	var b strings.Builder

	b.WriteString(fmt.Sprintf("func (%s *%s) Reset() {\n", r, st.Name))
	b.WriteString(fmt.Sprintf("\tif %s == nil {\n\t\treturn\n\t}\n", r))

	for _, f := range st.Fields {
		for _, n := range f.Names {
			fieldName := r + "." + n.Name
			b.WriteString(resetLine(fieldName, f.Type))
		}
	}

	b.WriteString("}\n")
	return b.String()
}

func resetLine(name string, t ast.Expr) string {
	switch tt := t.(type) {
	case *ast.Ident:
		if isPrimitive(tt.Name) {
			return "\t" + name + " = " + zeroVal(tt.Name) + "\n"
		}
		return "\t" + name + " = " + exprString(t) + "{}\n"
	case *ast.ArrayType:
		if tt.Len == nil {
			return "\tif " + name + " != nil {\n\t\t" + name + " = " + name + "[:0]\n\t}\n"
		}
		return "\t" + name + " = " + exprString(t) + "{}\n"
	case *ast.MapType:
		return "\tif " + name + " != nil {\n\t\tclear(" + name + ")\n\t}\n"
	case *ast.StarExpr:
		return pointerResetLine(name, tt)
	default:
		return "\t" + name + " = " + exprString(t) + "{}\n"
	}
}

func pointerResetLine(name string, tt *ast.StarExpr) string {
	var b strings.Builder
	b.WriteString("\tif " + name + " != nil {\n")
	switch elem := tt.X.(type) {
	case *ast.Ident:
		if isPrimitive(elem.Name) {
			b.WriteString("\t\t*" + name + " = " + zeroVal(elem.Name) + "\n")
		} else {
			b.WriteString("\t\t*" + name + " = " + exprString(elem) + "{}\n")
		}
	default:
		b.WriteString("\t\t*" + name + " = " + exprString(tt.X) + "{}\n")
	}
	b.WriteString("\t}\n")
	return b.String()
}

func isPrimitive(name string) bool {
	switch name {
	case "int", "int8", "int16", "int32", "int64",
		"uint", "uint8", "uint16", "uint32", "uint64", "uintptr",
		"float32", "float64",
		"string",
		"bool":
		return true
	}
	return false
}

func zeroVal(name string) string {
	switch name {
	case "string":
		return `""`
	case "bool":
		return "false"
	case "float32", "float64":
		return "0.0"
	default:
		return "0"
	}
}

func exprString(e ast.Expr) string {
	switch v := e.(type) {
	case *ast.Ident:
		return v.Name
	case *ast.StarExpr:
		return "*" + exprString(v.X)
	case *ast.ArrayType:
		return "[]" + exprString(v.Elt)
	case *ast.SelectorExpr:
		return exprString(v.X) + "." + v.Sel.Name
	case *ast.MapType:
		return "map[" + exprString(v.Key) + "]" + exprString(v.Value)
	}
	return ""
}

func receiverVar(typeName string, pkg *packages.Package) string {
	r := findExistingReceiver(typeName, pkg)
	if r != "" {
		return r
	}
	return strings.ToLower(string(typeName[0]))
}

func findExistingReceiver(typeName string, pkg *packages.Package) string {
	for _, file := range pkg.Syntax {
		for _, decl := range file.Decls {
			funcDecl, ok := decl.(*ast.FuncDecl)
			if !ok || funcDecl.Recv == nil {
				continue
			}
			if isReceiverOfType(funcDecl, typeName) {
				if len(funcDecl.Recv.List) > 0 {
					if len(funcDecl.Recv.List[0].Names) > 0 {
						return funcDecl.Recv.List[0].Names[0].Name
					}
				}
			}
		}
	}
	return ""
}

func isReceiverOfType(funcDecl *ast.FuncDecl, typeName string) bool {
	if funcDecl.Recv == nil {
		return false
	}
	for _, field := range funcDecl.Recv.List {
		switch t := field.Type.(type) {
		case *ast.StarExpr:
			if ident, ok := t.X.(*ast.Ident); ok && ident.Name == typeName {
				return true
			}
		case *ast.Ident:
			if t.Name == typeName {
				return true
			}
		}
	}
	return false
}
